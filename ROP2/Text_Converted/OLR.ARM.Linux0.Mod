MODULE Linux0;	(* rc/ard/nm/jm/devil/pjm/rml*)

(* Linux kernel interface for ARM *)

(* OBERON System 3, Release 2.2.

Copyright 1997 Team of the Institute of Computer Systems of ETH Zuerich,
ETH Center, CH-8092 Zuerich, e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be requested from the 
above-mentioned address, or downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

(** Module Kernel is responsible for memory allocation, garbage collection and other run-time 
support for the Oberon language, as well as interfacing to the underlying machine.  Using features 
exported from module Kernel may result in an unportable module, as not all Oberon Kernels are 
the same. This module is of little importance to most Oberon programmers. *)

(*	Peter Matthias
	2015-12-09	split OLR.Kernel.Mod to OLR.ARM.Linux0.Mod and OLR.MIPS.Linux0.Mod
	2017-03-24	WIP changing data layout
	2017-06-05	Fixup: added softDiv for 32bit calls

	ToDo: use UDF to trap in Div !
*)


IMPORT SYSTEM;

CONST
	ARCH*="ARMv7";
	ObjPrefix*="armv7/";
	ObjTag*=36FBH;	(* x86: 0AFX; arml: 0F5X; arm: 36FBH; mips: 36F9H; mipst: 36FAH *)
	RegSize*=32;
	PageSize*=1000H;

	(* registers for ARM 32 *)
	ARI*=0; FP*=12; SP* = 13; LR* = 14; PC = 15;

	LDMIA1= 0E8900001H+SP*10000H; LDMIA2=LDMIA1+2; LDMIA3= LDMIA2+4; LDMIA4=LDMIA3+8; LDMIA5=LDMIA4+16; LDMIA6=LDMIA5+32;
	NOP=0E320F000H;	SVC= 0EF000000H;	(*BX=0E12FFF1EH;*)	UDF=0E7F000F0H;	XTRAP*=UDF;
	BX=0EA000000H;	(* BX= 0E12FFF1EH; jump=0EA000000H (B+2) jump being removed by compiler *)	

	ATFDCWD*=-100;	(* use current working directory *)

	(** Open( .. ) flags *)
	ORDonly*= 0;	OWRonly*= 1;	ORDWR*=2;	OCREAT*= 40H;	OEXCL*= 80H;	OTRUNC*= 200H;	OAPPEND*=400H;	ODSYNC*=1000H;(* from MIPS *)
	ODirectory*=0;
	(** FLock( .. ) *)
	LOCKEX*= 2;	LOCKNB*= 4;	LOCKUN*= 8;
	(** LSeek *)
	SEEKSET*=0;	SEEKCURRENT*=1;	SEEKEND*=2;
	(** Mmap *)
	MAPSHARED*=1; MAPPRIVATE*=2; MAPANONYMOUS*=20H;	(* ARM: 20H; MIPS: 800H *)

(*	PROTEXEC= PROTREAD=	; PROTWRITE=	PROTNONE=	*)

	(* Termios used in Input (FB) *)

(* ARM *)
	VMIN*= 6;
	TCGETS*= 5401H;
	TCSETSF*= 5404H;

	(** Socket *)
	SOCKSTREAM*=1;		(* was 1 for X86 and ARM, 2 for MIPS ??*)

(* Common *)
	SIGHUP= 1;		(* Hang up ; X11 quits *)
	SIGINT*= 2;			(* interrupt	 ctrl-c *)
	SIGQUIT= 3;		(* quit	ctrl-# , ctrl-4 ?, PrintScreen? *)
	SIGILL* = 4;			(* invalid instruction ?*)
	SIGTRAP*= 5;		(* HALT( x) *)
	SIGFPE* = 8;		(* DIV 0 *)
	SIGKILL= 9;	(* kill *)
	SIGSEGV*= 11;	(* segmentation fault *)
	SIGPIPE*= 13;	(* in KDE alt-F4 *)
	SIGALRM= 14;	(* signal  from alarm(1) *)
	SIGTERM = 15;	(* ctrl-alt-del *)
	SIGPROF= 29;
	SIGXCPU= 30;
	SIGXFSZ= 31;

(* ARM: *)
	SIGABRT= 6;
	SIGBUS* = 7;	(* unused *)
	SIGUSR1*= 10;	(* used by Display for framebuffer console switching *)
	SIGUSR2*= 12;	(* used by Display for framebuffer console switching *)
	SIGSTKFLT= 16;	(* floating point stack error *)
	SIGCHLD*= 17;	(* child quit *)
	SIGCONT*= 18;
	SIGSTOP= 19;
	SIGTSTP= 20;		(* tty stop *)
	SIGTTIN= 21;		(* tty *)
	SIGTTOU= 22;	(* tty *)
	SIGIO= 23;		(* io error *)
	SIGWINCH= 28;	(* window changed *)

	RegDist*=1;	(* SC.regs =32 bit *)


TYPE
	Proc*= PROCEDURE;

(* ARM *)
	SigContext*= POINTER TO RECORD
		dummy: ARRAY 5 OF LONGINT;
		trapNo*, errCode, oldMask: LONGINT;
		regs*: ARRAY 15 OF LONGINT;
		pc*: LONGINT;
		cpsr, faultAddr, signal2: LONGINT;
		fpregs*: ARRAY 32 OF LONGINT;
	END;

	SigInfo*= POINTER TO RECORD	(* dummy *)
		adr*: LONGINT;
	END;

	Status* = RECORD	(* ARM*)
		a1, a2, a3, a4: LONGINT;
		b1, b2, b3, b4: LONGINT;
		c1, c2, c3, c4: LONGINT;
		size*, d2, blksize*, d4: LONGINT;
		e1, e2, atime*, atimens: LONGINT;
		mtime*, mtimens, ctime*, ctimens: LONGINT;
		g1, g2, g3, g4: LONGINT;
		h1, h2, h3, h4: LONGINT;
		i1, i2, i3, i4: LONGINT;
		j1, j2, j3, j4: LONGINT;
	END;

	SockAddrUn*= RECORD
		pf*: INTEGER;
		path*: ARRAY 64 OF CHAR;	(* was 30 for MIPS; 64 for ARM *)
	END;
VAR
	Regs*: ARRAY 16 OF LONGINT;
	FRegs*: ARRAY 32 OF LONGINT;
	softDiv: PROCEDURE;

(* This routine has been taken from NetBSD 1.3.3 and is *VERY* slightly modified; same routine as in legacy ARM Oberon *)
(* R0 = R1 DIV R0; R1 = R1 MOD R0 *)

PROCEDURE Div;
BEGIN

	SYSTEM.CODE( 0E3500001H);	(* CMP*)

	SYSTEM.CODE( 0AA000000H);	(* BCS *)
	SYSTEM.CODE( UDF+0A00H);	(* TRAP *)

	SYSTEM.CODE( 1A00001H);	(* MOVEQ R0,R1 *)
	SYSTEM.CODE( 3A01000H);	(* MOVEQ R1,0H *)
	SYSTEM.CODE( 12FFF1EH);	(* BX EQ LR *)

(*1*)
	SYSTEM.CODE( 0E1A05000H);
	SYSTEM.CODE( 0E2104102H);
	SYSTEM.CODE( 042600000H);
	SYSTEM.CODE( 0E2112102H);
	SYSTEM.CODE( 0E0244002H);
	SYSTEM.CODE( 042611000H);
	SYSTEM.CODE( 0E18240A4H);
	SYSTEM.CODE( 0E3A02001H);
	SYSTEM.CODE( 0E3A03000H);
	SYSTEM.CODE( 0E1510000H);
	SYSTEM.CODE( 03A00009BH);
	SYSTEM.CODE( 0E1510080H);
	SYSTEM.CODE( 03A000096H);
	SYSTEM.CODE( 0E1510100H);
	SYSTEM.CODE( 03A000091H);
	SYSTEM.CODE( 0E1510180H);
(*2*)
	SYSTEM.CODE( 03A00008CH);
	SYSTEM.CODE( 0E1510200H);
	SYSTEM.CODE( 03A000087H);
	SYSTEM.CODE( 0E1510280H);
	SYSTEM.CODE( 03A000082H);
	SYSTEM.CODE( 0E1510300H);
	SYSTEM.CODE( 03A00007DH);
	SYSTEM.CODE( 0E1510380H);
	SYSTEM.CODE( 03A000078H);
	SYSTEM.CODE( 0E1510400H);
	SYSTEM.CODE( 03A000073H);
	SYSTEM.CODE( 0E1510480H);
	SYSTEM.CODE( 03A00006EH);
	SYSTEM.CODE( 0E1510500H);
	SYSTEM.CODE( 03A000069H);
	SYSTEM.CODE( 0E1510580H);
(*3*)
	SYSTEM.CODE( 03A000064H);
	SYSTEM.CODE( 0E1510600H);
	SYSTEM.CODE( 03A00005FH);
	SYSTEM.CODE( 0E1510680H);
	SYSTEM.CODE( 03A00005AH);
	SYSTEM.CODE( 0E1510700H);
	SYSTEM.CODE( 03A000055H);
	SYSTEM.CODE( 0E1510780H);
	SYSTEM.CODE( 03A000050H);
	SYSTEM.CODE( 0E1510800H);
	SYSTEM.CODE( 03A00004BH);
	SYSTEM.CODE( 0E1510880H);
	SYSTEM.CODE( 03A000046H);
	SYSTEM.CODE( 0E1510900H);
	SYSTEM.CODE( 03A000041H);
	SYSTEM.CODE( 0E1510980H);
(*4*)
	SYSTEM.CODE( 03A00003CH);
	SYSTEM.CODE( 0E1510A00H);
	SYSTEM.CODE( 03A000037H);
	SYSTEM.CODE( 0E1510A80H);
	SYSTEM.CODE( 03A000032H);
	SYSTEM.CODE( 0E1510B00H);
	SYSTEM.CODE( 03A00002DH);
	SYSTEM.CODE( 0E1510B80H);
	SYSTEM.CODE( 03A000028H);
	SYSTEM.CODE( 0E1510C00H);
	SYSTEM.CODE( 03A000023H);
	SYSTEM.CODE( 0E1510C80H);
	SYSTEM.CODE( 03A00001EH);
	SYSTEM.CODE( 0E1510D00H);
	SYSTEM.CODE( 03A000019H);
	SYSTEM.CODE( 0E1510D80H);
(*5*)
	SYSTEM.CODE( 03A000014H);
	SYSTEM.CODE( 0E1510E00H);
	SYSTEM.CODE( 03A00000FH);
	SYSTEM.CODE( 0E1510E80H);
	SYSTEM.CODE( 03A00000AH);
	SYSTEM.CODE( 0E1510F00H);
	SYSTEM.CODE( 03A000005H);
	SYSTEM.CODE( 0E1510F80H);
	SYSTEM.CODE( 020411F80H);
	SYSTEM.CODE( 020833F82H);
	SYSTEM.CODE( 0E1510F00H);
	SYSTEM.CODE( 020411F00H);
	SYSTEM.CODE( 020833F02H);
	SYSTEM.CODE( 0E1510E80H);
	SYSTEM.CODE( 020411E80H);
	SYSTEM.CODE( 020833E82H);
(*6*)
	SYSTEM.CODE( 0E1510E00H);
	SYSTEM.CODE( 020411E00H);
	SYSTEM.CODE( 020833E02H);
	SYSTEM.CODE( 0E1510D80H);
	SYSTEM.CODE( 020411D80H);
	SYSTEM.CODE( 020833D82H);
	SYSTEM.CODE( 0E1510D00H);
	SYSTEM.CODE( 020411D00H);
	SYSTEM.CODE( 020833D02H);
	SYSTEM.CODE( 0E1510C80H);
	SYSTEM.CODE( 020411C80H);
	SYSTEM.CODE( 020833C82H);
	SYSTEM.CODE( 0E1510C00H);
	SYSTEM.CODE( 020411C00H);
	SYSTEM.CODE( 020833C02H);
	SYSTEM.CODE( 0E1510B80H);
(*7*)
	SYSTEM.CODE( 020411B80H);
	SYSTEM.CODE( 020833B82H);
	SYSTEM.CODE( 0E1510B00H);
	SYSTEM.CODE( 020411B00H);
	SYSTEM.CODE( 020833B02H);
	SYSTEM.CODE( 0E1510A80H);
	SYSTEM.CODE( 020411A80H);
	SYSTEM.CODE( 020833A82H);
	SYSTEM.CODE( 0E1510A00H);
	SYSTEM.CODE( 020411A00H);
	SYSTEM.CODE( 020833A02H);
	SYSTEM.CODE( 0E1510980H);
	SYSTEM.CODE( 020411980H);
	SYSTEM.CODE( 020833982H);
	SYSTEM.CODE( 0E1510900H);
	SYSTEM.CODE( 020411900H);
(*8*)
	SYSTEM.CODE( 020833902H);
	SYSTEM.CODE( 0E1510880H);
	SYSTEM.CODE( 020411880H);
	SYSTEM.CODE( 020833882H);
	SYSTEM.CODE( 0E1510800H);
	SYSTEM.CODE( 020411800H);
	SYSTEM.CODE( 020833802H);
	SYSTEM.CODE( 0E1510780H);
	SYSTEM.CODE( 020411780H);
	SYSTEM.CODE( 020833782H);
	SYSTEM.CODE( 0E1510700H);
	SYSTEM.CODE( 020411700H);
	SYSTEM.CODE( 020833702H);
	SYSTEM.CODE( 0E1510680H);
	SYSTEM.CODE( 020411680H);
	SYSTEM.CODE( 020833682H);
(*9*)
	SYSTEM.CODE( 0E1510600H);
	SYSTEM.CODE( 020411600H);
	SYSTEM.CODE( 020833602H);
	SYSTEM.CODE( 0E1510580H);
	SYSTEM.CODE( 020411580H);
	SYSTEM.CODE( 020833582H);
	SYSTEM.CODE( 0E1510500H);
	SYSTEM.CODE( 020411500H);
	SYSTEM.CODE( 020833502H);
	SYSTEM.CODE( 0E1510480H);
	SYSTEM.CODE( 020411480H);
	SYSTEM.CODE( 020833482H);
	SYSTEM.CODE( 0E1510400H);
	SYSTEM.CODE( 020411400H);
	SYSTEM.CODE( 020833402H);
	SYSTEM.CODE( 0E1510380H);
(*10*)
	SYSTEM.CODE( 020411380H);
	SYSTEM.CODE( 020833382H);
	SYSTEM.CODE( 0E1510300H);
	SYSTEM.CODE( 020411300H);
	SYSTEM.CODE( 020833302H);
	SYSTEM.CODE( 0E1510280H);
	SYSTEM.CODE( 020411280H);
	SYSTEM.CODE( 020833282H);
	SYSTEM.CODE( 0E1510200H);
	SYSTEM.CODE( 020411200H);
	SYSTEM.CODE( 020833202H);
	SYSTEM.CODE( 0E1510180H);
	SYSTEM.CODE( 020411180H);
	SYSTEM.CODE( 020833182H);
	SYSTEM.CODE( 0E1510100H);
	SYSTEM.CODE( 020411100H);
(*11*)
	SYSTEM.CODE( 020833102H);
	SYSTEM.CODE( 0E1510080H);
	SYSTEM.CODE( 020411080H);
	SYSTEM.CODE( 020833082H);
	SYSTEM.CODE( 0E1510000H);
	SYSTEM.CODE( 020411000H);
	SYSTEM.CODE( 020833002H);
	SYSTEM.CODE( 0E3140202H);
	SYSTEM.CODE( 01A000006H);
	SYSTEM.CODE( 0E1A00003H);
	SYSTEM.CODE( 0E3540000H);
	SYSTEM.CODE( 042611000H);
	SYSTEM.CODE( 0E1B04084H);
	SYSTEM.CODE( 043C00102H);
	SYSTEM.CODE( 042600000H);
	SYSTEM.CODE( 0EA000007H);
(*12*)
	SYSTEM.CODE( 0E3140201H);
	SYSTEM.CODE( 0E1A01081H);
	SYSTEM.CODE( 013811001H);
	SYSTEM.CODE( 0E1A03083H);
	SYSTEM.CODE( 0E1510000H);
	SYSTEM.CODE( 020411000H);
	SYSTEM.CODE( 020833002H);
	SYSTEM.CODE( 0E1A00003H);
	SYSTEM.CODE( 0E3510000H);
	SYSTEM.CODE( 0AA000004H);
	SYSTEM.CODE( 0E3550000H);
	SYSTEM.CODE( 0A0811005H);
	SYSTEM.CODE( 0A2400001H);
	SYSTEM.CODE( 0B0411005H);
	SYSTEM.CODE( 0B2800001H);
END Div;

PROCEDURE Openat0*( dirfd, name, flags, mode: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA4);	(*LDMIA   SP!, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 142H);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Openat0;

PROCEDURE Close0*( fd: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA1);	(*LDMIA   SP, {R0 } *)
	SYSTEM.PUTREG(7, 6);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Close0;

PROCEDURE Read0*( fd, buf, num: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 3);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Read0;

PROCEDURE Readv0*( fd, vect, cnt: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 145);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Readv0;

PROCEDURE Write0*( fd, buf, num: LONGINT): LONGINT;	
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 4);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Write0;

PROCEDURE Writev0*( fd, vect, cnt: LONGINT): LONGINT;	
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 146);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Writev0;

PROCEDURE Brk0*( adr: LONGINT):LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA1);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 45);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Brk0;

PROCEDURE Exit0*(arg: LONGINT);
BEGIN
	SYSTEM.CODE(LDMIA1);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 1);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Exit0;

PROCEDURE Creat0*( name, mode: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA2);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 8);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Creat0;

PROCEDURE MProtect0*( adr, len, prot: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 125);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END MProtect0;

PROCEDURE SIGAction0*( signum, act, oldact: LONGINT): LONGINT;	
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 67);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END SIGAction0;

PROCEDURE FStat0*( fd, stat: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA2);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 197);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END FStat0;

PROCEDURE Mmap20*( addr, len, prot, flags, fd, off: LONGINT):LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA6);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 192);				(* E3A07005	MOV   R7,192 *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Mmap20;

PROCEDURE Munmap0*( addr, len: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA2);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 91);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Munmap0;

PROCEDURE CacheFlush0*( adr, bytes: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA2);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 0F0002H);				(* ARM_NR_cacheflush = 0F0002H *)
	SYSTEM.CODE(0E0811000H);	(* ADD	R1, R1, R0		 ARM needs beg, end adr *)
	SYSTEM.PUTREG(2, 0);
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END CacheFlush0;

(* Files *)
PROCEDURE LSeek0*( fd, pos, whence: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 19);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END LSeek0;

PROCEDURE FLock0*( fd, arg: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA2);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 143);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END FLock0;

PROCEDURE Ftruncate0*( fd, len: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA2);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 93);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Ftruncate0;

PROCEDURE UTimensat0*( dirfd, name, utimebuf, flags: LONGINT):LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA4);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 348);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END UTimensat0;

PROCEDURE GetTimeOfDay*(tv, tz: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA2);	(*LDMIA   SP, {R0 R1 } *)
	SYSTEM.PUTREG(7, 78);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.PUTREG(2, 0);
	SYSTEM.PUTREG(3, 0);
	SYSTEM.PUTREG(4, 0);
	SYSTEM.PUTREG(5, 0);
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END GetTimeOfDay;

PROCEDURE Renameat0*( olddfd, old, newdfd, new, flags: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA5);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 149H);				(* RENAMEAT=149H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Renameat0;

PROCEDURE UnLinkat0*( dirfd, name, flags: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 328);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END UnLinkat0;

PROCEDURE Mremap0*( oldaddr, oldsize, newsize, flags, naddr: LONGINT): LONGINT;
(* MREMAP_MAYMOVE=1 *)
BEGIN
	SYSTEM.CODE(LDMIA5);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 163);				(* E3A07005	MOV   R7,163 *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Mremap0;

PROCEDURE FStatat0*( dirfd, name, stat, flags: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA4);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 147H);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END FStatat0;

PROCEDURE GetDents0*( fd, bufptr, count: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 217);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END GetDents0;

PROCEDURE Socket0*( n1, n2, n3: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 119H);				(* E3A07005	MOV   R7,119H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Socket0;

PROCEDURE Connect0*( sockfd, servaddr, addrlen: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 11BH);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Connect0;

PROCEDURE Shmget0*( key, size, shmflag: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 133H);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Shmget0;

PROCEDURE Shmat0*(shmid, addr, flags: LONGINT): LONGINT;
BEGIN
		SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
		SYSTEM.PUTREG(7, 131H);				(* E3A07005	MOV   R7,5H *)
		SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
		SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Shmat0;

PROCEDURE Shmdt0*(addr: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA1);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 132H);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Shmdt0;

PROCEDURE ShmCtl0*(buf, cmd, shmid: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 134H);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END ShmCtl0;

PROCEDURE IOCtl0*( d, r1, r2: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA3);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 54);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END IOCtl0;

PROCEDURE Select0*( n, reafds, writefds, execptfds, timeout: LONGINT): LONGINT;
BEGIN
	SYSTEM.CODE(LDMIA5);	(*LDMIA   SP, {R0 R1 R2 } *)
	SYSTEM.PUTREG(7, 142);				(* E3A07005	MOV   R7,5H *)
	SYSTEM.CODE(SVC);	(* EF000000	SWI	0H *)
	SYSTEM.CODE(BX);	(* E1A0F00E	MOV PC,LR *)
END Select0;

PROCEDURE WriteHex(x: LONGINT);
VAR
	buf: ARRAY 10 OF CHAR;
	i, res: LONGINT;
BEGIN
	FOR i := 7 TO 0 BY -1 DO
		buf[i] := CHR(x MOD 10H + 48);
		IF buf[i] > "9" THEN
			buf[i] := CHR(ORD(buf[i]) +(- 48 + 65 - 10))
		END;
		x := x DIV 10H
	END;
	buf[8] := " ";
	res:=Write0(0, SYSTEM.ADR(buf), 9);
END WriteHex;

(* Linux0.Fixup and  RBootLinker.FixupA are same, don't optimize as in A32Decoder.Obj  *)
PROCEDURE Fixup*( base, entry, L: LONGINT; data: BOOLEAN);	
CONST (* instruction format *)
	BL=0EB000000H;	MOVIA2= 0E3000000H;	MOVT= 0E3400000H;
	IMM12=1000H; IMM16=10000H; IMM20= 100000H; IMM24=1000000H; IMM28=10000000H;
VAR L1, c1, c2, c3, d0: LONGINT;
BEGIN
	IF (entry#0) & (L # 0) THEN
		REPEAT
			L1 := L; SYSTEM.GET( base+L1*4, c1);
			IF c1 DIV IMM20= MOVIA2 DIV IMM20 THEN		(* load, store, adr *) (* wrong code with ARMv7 ROP2 compiler ??*)
				L := L1  + SYSTEM.LSH( c1, 16) DIV IMM16 +1;
				SYSTEM.GET( base+L1*4+4, c2);
				IF c2=MIN(LONGINT)+1 THEN	(* new softDiv *)
					c2:= SYSTEM.VAL(LONGINT, softDiv);
(*
					SYSTEM.GET( base+L1*4+8, c3);
					ASSERT( c3 DIV 10H=0E12FFF30H DIV 10H);
*)
				ELSE INC(c2, entry);
				END;
				SYSTEM.PUT( base+L1*4, MOVIA2+ c2 DIV IMM12 MOD 10H *IMM16+ c1 DIV IMM16 MOD 10H * IMM12+ c2 MOD IMM12);
				SYSTEM.PUT( base+L1*4+4, MOVT+ c2 DIV IMM28 MOD 10H *IMM16+ c1 DIV IMM16 MOD 10H * IMM12+ c2 DIV IMM16 MOD IMM12);
(*	only needed when branch is used for external procedure call
			ELSIF c1 DIV IMM24= BL DIV IMM24 THEN	(* procedure call *)	(* to be fixed in OPL.Exit, adjustLink ? *)
				L := L1 + SYSTEM.LSH( c1, 16) DIV IMM16+1;
				IF ( c1 DIV IMM16 MOD 100H=1) THEN	(* old softDiv *)
					c2:=( SYSTEM.VAL(LONGINT, softDiv) - base) DIV 4-L1-2;
					SYSTEM.PUT( base+L1*4, BL+ c2 MOD IMM24 );
				ELSE
					c2:=(entry - base) DIV 4-L1-2;
					SYSTEM.PUT( base+L1*4, BL+ c2 MOD IMM24);
				END;
				IF c2<=0FF800000H THEN d0:=Write0(0, SYSTEM.ADR("Error in Linux0.Fixup distance too high"), 39); WriteHex( c2) END;
*)
			ELSE d0:=Write0(0, SYSTEM.ADR("Error in Linux0.Fixup "), 22); WriteHex( L*4); WriteHex( L1*4); WriteHex( c1); WriteHex( c2);RETURN
			END;
		UNTIL L = L1
	END
END Fixup;

(* ARM *)
PROCEDURE SetSignal*( nr: LONGINT; handler: Proc): LONGINT;
CONST SARESTART= 10000000H;
TYPE
	SigAction = RECORD
		handler: Proc;
		sigaction: LONGINT;
		mask: SET;
		flags, restorer: LONGINT;
	END;
VAR h: SigAction;
BEGIN
	h.handler:= handler;
	h.mask:= {};
	h.flags:= SARESTART;
	h.restorer:= 0;
	RETURN SIGAction0( nr, SYSTEM.ADR(h), 0);
END SetSignal;

PROCEDURE CopyRegs*( sc: SigContext);
VAR i: LONGINT;
BEGIN
	i:=LEN(sc.regs);
	REPEAT
		DEC(i);
		Regs[i]:=sc.regs[i];
		FRegs[i]:=sc.fpregs[i];
		FRegs[i+16]:=sc.fpregs[i+16];
	UNTIL i=0;
END CopyRegs;

BEGIN
	softDiv:=Div;
(*
	SYSTEM.CODE(0EEF10A10H);	
	SYSTEM.CODE(0E3801880H);
	SYSTEM.CODE(0EEE11A10H);
*)
(*
		OPL.PutR( OPL.VMRS, OPL.T0, 1, 0);	(* set rounding to -inf; normal state round to nearest *)
		OPL.PutI( OPL.ORI, OPL.T1, OPL.T0, 880H);
		OPL.PutR( OPL.VMSR, OPL.T1, 1, 0);
*)
END Linux0.

